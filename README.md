# Векторизация и параллелизм
Мельников Лев КБ16
## Задание 1
Вариант 21

Целочисленное умножение

Для целочисленного умножения были написаны циклы, использующие целочисленное умножение.
Также для этих циклов были написаны копии с использованием intrinsics.
Замер времени производился для среднего из 10 попыток. Количество повторов в цикле
10 000 000. Для циклов с intrinsics количество повторов делилось на количество
элементов в векторе для эмуляции увеличения производительности. Каждый цикл
имел две версии - одна с вычислением от предыдущего результата, одна с вычислением
без зависимости. Для уменьшение влияния счетчика итерация инструкции в цикле дублированы
10 раз.

### Результаты:
#### Домашний ПК

```
{"name":"func_naive_latency", "avg":275.411}
{"name":"func_naive_throughoutput", "avg":51.5934}
{"name":"func_2_latency", "avg":177.5}
{"name":"func_2_throughoutput", "avg":17.9842}
Illegal instruction (core dumped) 
```

#### Сервер 

```
{"name":"func_naive_latency", "avg":187.916}
{"name":"func_naive_throughoutput", "avg":25.7463}
{"name":"func_2_latency", "avg":128.754}
{"name":"func_2_throughoutput", "avg":18.1055}
{"name":"func_4_latency", "avg":70.7719}
{"name":"func_4_throughoutput", "avg":10.197}
{"name":"func_8_latency", "avg":42.8926}
{"name":"func_8_throughoutput", "avg":42.9218}
```

### Выводы
Использование SIMD несомненно ускоряет вычисления. Однако используя его нужно быть очень аккуратным
и принимать во внимание много деталей в т.ч. разницу между темпом выдачи и латентностью.

## Задание 2
Вычисление интеграла.

Для этой задачи была выбрана функция x^2. Посчитаны 1 801 800 000 значений в точках (~400 МБ). Далее
был вычеслен интеграл методом прямоугольников, это значение взято за идеал.
Далее были реализованы функции использующие SSE, AVX2, AVX512 вычисляющие этой интеграл.
Далее была реализована функция запускающая вычисления в нескольких потоков.
Далее были замерены все сочетаний доступного количество потоков и вычисляющих функций. Далее
была собрана программа с помощью компилятора gcc и запущена на сервере. Класс задачи compute-bound.

### Результаты

| Threads    | Naive           | SSE(2x)   | AVX2 (4x) | AVX512 (8x) |
| ---------- |:---------------:|:---------:|:---------:|:-----------:|
| 1          | 4.24            | 4.27      | 2.27      | 1.15        |
| 2          | 2.21            | 2.12      | 1.15      | 0.77        |
| 3          | 1.44            | 1.42      | 0.78      | 0.53        |
| 4          | 1.38            | 1.06      | 0.58      | 0.39        |
| 5          | 0.97            | 0.85      | 0.47      | 0.32        |
| 6          | 0.91            | 0.91      | 0.50      | 0.34        |
| 7          | 0.82            | 0.94      | 0.49      | 0.33        |
| 8          | 0.72            | 0.84      | 0.45      | 0.29        |
| 9          | 0.71            | 0.86      | 0.44      | 0.29        |
| 10         | 0.67            | 0.83      | 0.40      | 0.29        |
| 11         | 0.65            | 0.78      | 0.39      | 0.28        |
| 12         | 0.61            | 0.82      | 0.39      | 0.26        |

### Выводы

С помощью параллелизма и векторизации вполне реально ускорить вычисления
в 20 раз. Однако нужно помнить огромное количество нюансов про latency и
throughtput, выравнивание и т.д. Разные intrinsics ведут себя по разному
и для успешной оптимизации нужно измерить все доступные решения.

